#!/usr/bin/perl

# all gitolite CLI tools run as sub-commands of this command
# ----------------------------------------------------------------------

=for args
Usage:  gitolite [sub-command] [options]

The following subcommands are available; they should all respond to '-h' if
you want further details on each:

    setup                       1st run: initial setup; all runs: hook fixups
    compile                     compile gitolite.conf

    query-rc                    get values of rc variables
    post-compile                run a post-compile command

    list-groups                 list all group names in conf
    list-users                  list all users/user groups in conf
    list-repos                  list all repos/repo groups in conf
    list-phy-repos              list all repos actually on disk
    list-memberships            list all groups a name is a member of
    list-members                list all members of a group

Warnings:
  - list-users is disk bound and could take a while on sites with 1000s of repos
  - list-memberships does not check if the name is known; unknown names come
    back with 2 answers: the name itself and '@all'
=cut

# ----------------------------------------------------------------------

use FindBin;

BEGIN { $ENV{GL_BINDIR} = $FindBin::RealBin; }
use lib $ENV{GL_BINDIR};
use Gitolite::Rc;
use Gitolite::Common;

use strict;
use warnings;

# ----------------------------------------------------------------------

my ( $command, @args ) = @ARGV;
args();

# the first two commands need options via @ARGV, as they have their own
# GetOptions calls and older perls don't have 'GetOptionsFromArray'

if ( $command eq 'setup' ) {
    shift @ARGV;
    require Gitolite::Setup;
    Gitolite::Setup->import;
    setup();

} elsif ( $command eq 'query-rc' ) {
    shift @ARGV;
    query_rc();     # doesn't return

# the rest don't need @ARGV per se

} elsif ( $command eq 'compile' ) {
    require Gitolite::Conf;
    Gitolite::Conf->import;
    compile(@args);

} elsif ( $command eq 'post-compile' ) {
    post_compile(@args);

} elsif ( -x "$rc{GL_BINDIR}/commands/$command" ) {
    trace( 2, "attempting gitolite command $command" );
    run_command( $command, @args );

} elsif ( $command eq 'list-phy-repos' ) {
    _chdir( $rc{GL_REPO_BASE} );
    print "$_\n" for ( @{ list_phy_repos(@args) } );

} elsif ( $command =~ /^list-/ ) {
    trace( 2, "attempting lister command $command" );
    require Gitolite::Conf::Load;
    Gitolite::Conf::Load->import;
    my $fn = lister_dispatch($command);
    print "$_\n" for ( @{ $fn->(@args) } );

} else {
    _die "unknown gitolite sub-command";
}

sub args {
    usage() if not $command or $command eq '-h';
}

# ----------------------------------------------------------------------

=for post_compile
Usage:  gitolite post-compile [-l] [post-compile-scriptname] [script args...]

    -l          list currently available post-compile scripts

Run a post-compile script (which normally runs from the post-update hook in
the gitolite-admin repo).
=cut

sub post_compile {
    usage() if ( not @_ or $_[0] eq '-h' );

    run_subdir( 'post-compile', @_ );
}

sub run_command {
    run_subdir( 'commands', @_ );
}

sub run_subdir {
    my $subdir = shift;
    if ( @_ and $_[0] eq '-l' ) {
        _chdir("$ENV{GL_BINDIR}/$subdir");
        map { say2($_) } grep { -x } glob("*");
        exit 0;
    }

    my $pgm      = shift;
    my $fullpath = "$ENV{GL_BINDIR}/$subdir/$pgm";
    _die "$pgm not found or not executable" if not -x $fullpath;
    _system( $fullpath, @_ );
    exit 0;
}
